
import Post from '../models/post.js';
import User from '../models/user.js';
import PostComment from '../models/post.comment.js';
import PostLike from '../models/post.like.js';
import PostBookmark from '../models/post.bookmark.js';
import Sequelize, { where } from 'sequelize';
import sequelize from '../models/sequelize.js';

const op = Sequelize.Op;

export default class PostRepository {
  PostFindOne = async (postId) => {
    const post = await Post.findOne({
      where: { id: postId },
    });

    return post;
  };
  PostLikeOne = async (postId, userName) => {
    const like = await PostLike.findOne({
      where: { postId: postId, userName: userName },
    });

    return like;
  };

  PostBookmarkOne = async (postId, userName) => {
    const bookmark = await PostBookmark.findOne({
      where: { postId: postId, userName: userName },
    });

    return bookmark;
  };

  PostShowAll = async (page, page_count) => {
    const post = await Post.findAll({
      offset: page_count * page,
      limit: page_count,
      attributes: [
        [
          sequelize.fn('substring', sequelize.col('content'), 1, 100),
          'content',
        ],
        'id',
        'title',
        'createdAt',
        'updatedAt',
        'likes',
        'tags',
      ],

      where: {},
      include: [
        { model: User, attributes: ['userName', 'profileImg'] },
        { model: PostComment, attributes: ['userName', 'comment'] },
        { model: PostLike, attributes: ['userName'] },
        { model: PostBookmark, attributes: ['userName'] },
      ],
      order: [['createdAt', 'DESC']],
    });

    return post;
  };

  PostShowHit = async () => {
    const post = await Post.findAll({
      limit: 4,
      where: {},
      include: [
        { model: User, attributes: ['userName', 'profileImg'] },
        { model: PostComment, attributes: ['userName', 'comment'] },
        { model: PostLike, attributes: ['userName'] },
        { model: PostBookmark, attributes: ['userName'] },
      ],
      attributes: [
        [
          sequelize.fn('substring', sequelize.col('content'), 1, 100),
          'content',
        ],
        'id',
        'title',
        'createdAt',
        'updatedAt',
        'likes',
        'tags',
      ],
      order: [['likes', 'DESC']],
    });

    return post.reverse();
  };

  PostShowOne = async (postId) => {
    const post = await Post.findOne({
      where: { id: postId },
      include: [
        { model: User, attributes: ['userName', 'profileImg'] },
        { model: PostComment, attributes: ['userName'] },
        { model: PostBookmark, attributes: ['userName'] },
        { model: PostLike, attributes: ['userName'] },
      ],
    });

    return post;
  };

  PostShowUser = async (userName) => {
    const post = await User.findOne({
      where: { userName: userName },
      attributes: [],
      include: [
        { model: Post, attributes: ['title', 'id', 'createdAt', 'likes'] },
        {
          model: PostComment,
          attributes: ['comment'],
          include: [
            {
              model: Post,
              where: { userName: { [op.ne]: userName } },
              attributes: ['title', 'id', 'createdAt', 'likes'],
            },
          ],
        },
      ],
      order: [['createdAt', 'DESC']],
    });

    return post;
  };

  PostCreate = async (title, content, tags, userName) => {
    const post = await Post.create({
      title,
      content,
      tags,
      userName,
    });

    return post;
  };

  PostUpdate = async (title, content, userName, postId) => {
    const post = await Post.update(
      { title, content, userName },
      { where: { id: postId, userName: userName } }
    );

    return post;
  };

  PostDelete = async (postId, userName) => {
    const post = await Post.destroy({
      where: { id: postId, userName: userName },
    });

    return post;
  };

  PostLike = async (postId, userName) => {
    const like = await PostLike.create({ postId, userName });
    await Post.increment({ like: 1 }, { where: { id: postId } });

    return like;
  };

  PostLikeDestroy = async (postId, userName) => {
    const likeDelete = await PostLike.destroy({
      where: { postId: postId, userName: userName },
    });
    await Post.decrement({ like: 1 }, { where: { id: postId } });

    return likeDelete;
  };

  PostBookmarkView = async (userName) => {
    const findBookMark = await PostBookmark.findAll({
      where: { userName: userName },
      include: {
        model: Post,
        attributes: ['title', 'userName', 'createdAt', 'id'],
      },
      attributes: [],
    });

    return findBookMark.reverse();
  };

  PostBookmark = async (postId, userName) => {
    const bookmark = await PostBookmark.create({
      postId,
      userName,
    });

    return bookmark;
  };

  PostBookmarkDestroy = async (postId, userName) => {
    const bookmark = await PostBookmark.destroy({
      where: { postId: postId, userName: userName },
    });

    return bookmark;
  };

  PostTags = async (tag, page, page_count) => {
    const tags = await Post.findOne({
      where: { tags: tag },
      include: [{ model: PostBookmark, attributes: ['userName'] }],
    });

    return tags;
  };
}
------------

import PostRepository from '../repositories/post.repository.js';
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from '../exception/customException.js';

export default class PostServices {
  postRepository = new PostRepository();
  // 최신순 정렬
  PostShowAll = async (userName, page, page_count) => {
    const post = await this.postRepository.PostShowAll(page, page_count);

    return post.map((post) => {
      let isBookmark = false;
      let isLike = false;
      for (let i = 0; i < post.PostLikes.length; i++) {
        if (post.PostLikes[i]?.userName === userName) {
          isLike = true;
        }
      }

      for (let i = 0; i < post.PostBookmarks.length; i++) {
        if (post.PostBookmarks[i]?.userName === userName) {
          isBookmark = true;
        }
      }
      let tags = post.tags.split(',');
      if (tags.length >= 4) tags.length = 3;

      return {
        id: post.id,
        title: post.title,
        content: post.content,
        createdAt: post.createdAt,
        updatedAt: post.updatedAt,
        userName: post.User.userName,
        isBookmark,
        isLike,
        tags,
        cntComment: post.PostComments.length,
        like: post.like,
        profileImg: post.User.profileImg,
      };
    });
  };

  // 댓글순 정렬
  PostShowComment = async (userName, page, page_count) => {
    const postcmt = await this.postRepository.PostShowAll(page, page_count);
    return postcmt
      .map((post) => {
        let isBookmark = false;
        let isLike = false;
        for (let i = 0; i < post.PostLikes.length; i++) {
          if (post.PostLikes[i]?.userName === userName) {
            isLike = true;
          }
        }
        for (let i = 0; i < post.PostBookmarks.length; i++) {
          if (post.PostBookmarks[i]?.userName === userName) {
            isBookmark = true;
          }
        }
        let tags = post.tags.split(',');

        if (tags.length >= 4) tags.length = 3;

        return {
          id: post.id,
          title: post.title,
          content: post.content,
          createdAt: post.createdAt,
          updatedAt: post.updatedAt,
          userName: post.User.userName,
          isBookmark,
          isLike,
          tags,
          profileImg: post.User.profileImg,
          cntComment: post.PostComments.length,
          like: post.like,
        };
      })
      .sort(function (a, b) {
        return b.cmtNum - a.cmtNum;
      });
  };

  // 추천순 정렬
  PostShowLike = async (userName) => {
    const postshowlike = await this.postRepository.PostShowHit();

    return postshowlike
      .map((post) => {
        let isBookmark = false;
        let isLike = false;
        for (let i = 0; i < post.PostLikes.length; i++) {
          if (post.PostLikes[i]?.userName === userName) {
            isLike = true;
          }
        }
        for (let i = 0; i < post.PostBookmarks.length; i++) {
          if (post.PostBookmarks[i]?.userName === userName) {
            isBookmark = true;
          }
        }
        let tags = post.tags.split(',');

        if (tags.length >= 4) tags.length = 3;
        return {
          id: post.id,
          title: post.title,
          content: post.content,
          createdAt: post.createdAt,
          updatedAt: post.updatedAt,
          userName: post.User.userName,
          isBookmark,
          isLike,
          tags,
          profileImg: post.User.profileImg,
          cntComment: post.PostComments.length,
          like: post.like,
        };
      })
      .sort((a, b) => {
        return b.like - a.like;
      });
  };

  PostShowhit = async (userName) => {
    const posthit = await this.postRepository.PostShowHit();
    const posthitmap = posthit.map((post) => {
      let isLike = false;

      for (let i = 0; i < post.PostLikes.length; i++) {
        if (post.PostLikes[i]?.userName === userName) {
          isLike = true;
        }
      }
      let tags = post.tags.split(',');

      if (tags.length >= 4) tags.length = 3;
      return {
        id: post.id,
        title: post.title,
        content: post.content,
        tags,
        createdAt: post.createdAt,
        updatedAt: post.updatedAt,
        userName: post.User.userName,
        isLike,
        profileImg: post.User.profileImg,
        cmtNum: post.PostComments.length,
        like: post.like,
      };
    });

    let posthits = [];
    let answer = [];
    let now = new Date();
    for (let i = 0; i < posthitmap.length; i++) {
      const datecompare =
        now.getTime() - new Date(posthitmap[i].createdAt).getTime();
      const inttime = datecompare / 1000 / 60 / 60;
      if (parseInt(inttime) < 24) {
        posthits.push(i);
      }
    }
    for (let i = 0; i < posthits.length; i++) {
      answer.push(posthitmap[i]);
    }

    return answer.sort((a, b) => {
      return b.like - a.like;
    });
  };

  PostShowOne = async (userName, postId) => {
    const post = await this.postRepository.PostShowOne(postId);
    if (!post) throw new BadRequestException('존재하지 않는 게시물입니다');
    let isBookmark = false;
    for (let i = 0; i < post.PostBookmarks.length; i++) {
      if (post.PostBookmarks[i]?.userName === userName) {
        isBookmark = true;
      }
    }

    let isLike = false;
    for (let i = 0; i < post.PostLikes.length; i++) {
      if (post.PostLikes[i]?.userName === userName) {
        isLike = true;
      }
    }

    return {
      id: post.id,
      title: post.title,
      content: post.content,
      tags: post.tags.split(','),
      createdAt: post.createdAt,
      isBookmark,
      isLike,
      profileImg: post.User.profileImg,
      userName: post.User.userName,
      cntComment: post.PostComments.length,
      like: post.like,
    };
  };

  PostShowUser = async (userName) => {
    const post = await this.postRepository.PostShowUser(userName);
    if (!post) throw new BadRequestException('존재하지 않는 유저 입니다');

    return {
      comment: post.PostComments,
      post: post.Posts,
    };
  };

  PostCreate = async (
    title,
    content,
    tags,
    userName,
    profileImg,
    like,
    cntComment,
    isLike
  ) => {
    if (content.length === 0 || title.length === 0) {
      throw new BadRequestException('내용을 입력해주세요');
    }

    tags = tags.toString();

    const post = await this.postRepository.PostCreate(
      title,
      content,
      tags,
      userName,
      profileImg,
      like
    );

    return {
      id: post.id,
      title: post.title,
      content: post.content,
      createdAt: post.createdAt,
      tags: post.tags.split(','),
      userName,
      profileImg,
      like: 0,
      cntComment,
      isLike,
    };
  };

  PostUpdate = async (title, content, userName, postId, profileImg) => {
    if (content.length === 0 || title.length === 0)
      throw new BadRequestException('내용이나 제목을 입력해주세요');
    const post1 = await this.postRepository.PostFindOne(postId);

    if (userName !== post1.userName) {
      throw new BadRequestException('본인의 글만 수정이 가능합니다');
    }

    const post = await this.postRepository.PostUpdate(
      title,
      content,
      userName,
      postId
    );
    if (post) {
      return {
        title,
        content,
        userName,
        id: parseInt(postId),
        profileImg,
      };
    }
  };

  PostDelete = async (postId, userName) => {
    const find = await this.postRepository.PostFindOne(postId);

    if (!find) throw new NotFoundException('게시물이 존재하지 않습니다');

    if (find.userName !== userName) {
      throw new NotFoundException('본인의 글만 삭제 가능합니다');
    }

    const post = await this.postRepository.PostDelete(postId, userName);

    return post;
  };

  PostLike = async (postId, userName) => {
    const findLike = await this.postRepository.PostLikeOne(postId, userName);
    if (findLike) throw new BadRequestException('이미 좋아요한 게시물입니다');
    if (!findLike) {
      const like = await this.postRepository.PostLike(postId, userName);
    }
  };

  PostLikeDelete = async (postId, userName) => {
    const findLike = await this.postRepository.PostLikeOne(postId, userName);
    if (findLike === null) {
      throw new BadRequestException('좋아요를 하지 않았습니다');
    } else {
      const like = await this.postRepository.PostLikeDestroy(postId, userName);
    }
  };

  PostBookMarkView = async (userName) => {
    const findBookMark = await this.postRepository.PostBookmarkView(userName);

    return findBookMark.map((bookmark) => {
      return {
        id: bookmark.Post.id,
        title: bookmark.Post.title,
        createdAt: bookmark.Post.createdAt,
        userName: bookmark.Post.userName,
      };
    });
  };

  PostBookMark = async (postId, userName) => {
    const findBookMark = await this.postRepository.PostBookmarkOne(
      postId,
      userName
    );

    if (findBookMark === null) {
      const bookmark = await this.postRepository.PostBookmark(postId, userName);
    } else {
      throw new BadRequestException('북마크를 이미 하였습니다');
    }
  };

  PostBookMarkDelete = async (postId, userName) => {
    const findBookMark = await this.postRepository.PostBookmarkOne(
      postId,
      userName
    );

    if (findBookMark === null) {
      throw new BadRequestException('즐겨찾기한 북마크가 없습니다');
    } else {
      const bookmark = await this.postRepository.PostBookmarkDestroy(
        postId,
        userName
      );
    }
  };
}
